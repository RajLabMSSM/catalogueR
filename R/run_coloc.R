#' Iteratively run coloc on merged GWAS-QTL datatables
#'
#' Runs colocalization tests (\code{\link{coloc::coloc.abf}}) on merged GWAS-QTL datatables
#' generated by \code{\link{catalogueR::eQTL_Catalogue.query}}.
#'
#' Iterately runs coloc across each:
#' \itemize{
#' \item{QTL dataset}
#' \item{GWAS locus}
#' \item{QTL gene}
#' }
#' @return
#' If \code{top_snp_only=T}, returns SNP-level stats for only the SNP
#' with the highest colocalization probability (\emph{SNP.PP.H4})
#' If \code{top_snp_only=T}, returns SNP-level stats for every SNP.
#' In either case, summary-level coloc stats are added in the columns
#' \emph{PP.H0}, \emph{PP.H1}, \emph{PP.H2}, \emph{PP.H3}, \emph{PP.H4}.
#' @family coloc
#' @examples
#' # With built-in data
#' gwas.qtl_paths <- example_eQTL_Catalogue_query_paths()
#' coloc_QTLs <- run_coloc(gwas.qtl_paths = gwas.qtl_paths, nThread = 4, top_snp_only = TRUE, save_path = "~/Desktop/coloc_results.tsv.gz")
#' \dontrun{
#' # With full  Nalls et al data (not included)
#' gwas.qtl_paths <- list.files("/pd-omics/brian/eQTL_catalogue/Nalls23andMe_2019", recursive = TRUE, full.names = TRUE)
#' coloc_QTLs.Nalls2019 <- run_coloc(gwas.qtl_paths = gwas.qtl_paths[1:100], nThread = 4, top_snp_only = TRUE, save_path = "~/Desktop/Nall2019.coloc_results.tsv.gz")
#' }
run_coloc <- function(gwas.qtl_paths,
                      save_path = "./coloc_results.tsv.gz",
                      nThread = 4,
                      top_snp_only = TRUE,
                      split_by_group = F,
                      method = "abf",
                      PP_threshold = .8,
                      gwas_sample_size = NULL) {
    # gwas.qtl_paths <- list.files("~/Desktop/Mount_Sinai/COVID19_PheWAS/GWAS_queries", recursive  = TRUE, full.names  = TRUE)
    # qtl.ID=unique(qtl.dat$qtl.id)[1]; eGene=unique(qtl.dataset$gene.QTL)[1];
    # qtl.ID = "Fairfax_2014.monocyte_naive"; eGene = "TSC22D2"; qtl.path=gwas.qtl_paths[1]
    # qtl.path="/Volumes/Scizor/eQTL_Catalogue/Nalls23andMe_2019/Alasoo_2018.macrophage_IFNg/MCCC1_locus__&__Alasoo_2018.macrophage_IFNg.tsv.gz"
    qtl.groups <- unique(unlist(lapply(gwas.qtl_paths, parse_gwas.qtl_path)))

    # Iterate over QTL groups
    coloc_QTLs <- timeit(lapply(qtl.groups, function(group) {
        message("+ QTL Group = ", group)
        gwas.qtl_paths_select <- gwas.qtl_paths[basename(dirname(gwas.qtl_paths)) == group]

        # ---- Iterate over QTL datasets
        coloc_qtls <- parallel::mclapply(gwas.qtl_paths_select, function(qtl.path,
                                                                         .gwas_sample_size = gwas_sample_size) {
            qtl_ID <- parse_gwas.qtl_path(gwas.qtl_path = qtl.path, get_locus = FALSE, get_qtl_id = TRUE)
            gwas.locus <- parse_gwas.qtl_path(gwas.qtl_path = qtl.path, get_locus = TRUE, get_qtl_id = FALSE)
            coloc_eGenes <- data.table::data.table()
            try({
                qtl.dat <- data.table::fread(qtl.path)
                message("++ GWAS = ", gwas.locus, " x ", length(unique(qtl.dat$gene.QTL)), " eGenes")
                #### Check column names ####

                ## Check sample size
                if (!"N" %in% colnames(gwas.locus)) {
                    if (is.null(gwas_sample_size)) {
                        stop("`N` column (sample size) not detected. Please provide `sample_size=` argument instead.")
                    } else {
                        qtl.dat$N <- .gwas_sample_size
                    }
                }
                if (!"qtl_id" %in% colnames(qtl.dat)) {
                    qtl.dat <- cbind(qtl.dat, qtl_id = qtl_ID)
                }
                qtl.dataset <- subset(qtl.dat, qtl_id == qtl_ID & !is.na(gene.QTL) & gene.QTL != "")
                remove(qtl.dat)

                # ---- Iterate over QTL eGenes
                coloc_eGenes <- lapply(unique(qtl.dataset$gene.QTL), function(eGene) {
                    messager("+++ QTL eGene =", eGene)
                    # Extract QTL cols
                    qtl.egene <- subset(qtl.dataset, gene.QTL == eGene)
                    # Extract the GWAS cols
                    if ("Effect" %in% colnames(qtl.egene)) {
                        gwas_cols <- c(
                            "Locus", "Locus.GWAS", "SNP", "CHR", "POS", "P", "Effect", "StdErr", "Freq",
                            "MAF", "N", "N_cases", "N_controls", "proportion_cases", "A1", "A2"
                        )
                        gwas_cols <- gwas_cols[gwas_cols %in% colnames(qtl.egene)]
                        gwas.region <- subset(qtl.egene, select = gwas_cols)
                    }
                    # Run coloc
                    coloc_res <- get_colocs(
                        qtl.egene = qtl.egene,
                        gwas.region = gwas.region,
                        merge_by_rsid = TRUE,
                        PP_threshold = PP_threshold,
                        method = method,
                        verbose = FALSE
                    )
                    coloc_summary <- as.list(coloc_res$summary)
                    coloc_results <- coloc_res$results
                    if (top_snp_only) {
                        coloc_results <- (coloc_results %>% top_n(n = 1, wt = SNP.PP.H4))[1, ]
                    }
                    # Rename columns
                    colnames(coloc_results) <- gsub("\\.df1", ".QTL", colnames(coloc_results))
                    colnames(coloc_results) <- gsub("\\.df2", ".GWAS", colnames(coloc_results))
                    # Create results dataframe
                    coloc_DT <- data.table::data.table(
                        Locus.GWAS = coloc_res$Locus,
                        qtl_id = qtl_ID,
                        gene.QTL = eGene,
                        P = gwas.region$P,
                        CHR = gwas.region$CHR,
                        POS = gwas.region$POS,
                        pvalue.QTL = qtl.egene$pvalue.QTL,
                        coloc_results,
                        PP.H0 = coloc_summary$PP.H0.abf,
                        PP.H1 = coloc_summary$PP.H1.abf,
                        PP.H2 = coloc_summary$PP.H2.abf,
                        PP.H3 = coloc_summary$PP.H3.abf,
                        PP.H4 = coloc_summary$PP.H4.abf
                    )
                    return(coloc_DT)
                }) %>% data.table::rbindlist(fill = TRUE) # END ITERATE OVER eGenes
            }) # end try()
            return(coloc_eGenes)
        }, mc.cores = nThread) %>% data.table::rbindlist(fill = TRUE) # END ITERATE OVER gwas.qtl_paths_select

        if (split_by_group) {
            split_path <- file.path(dirname(save_path), group)
            messager("Saving split file ==>", split_path)
            dir.create(dirname(split_path), showWarnings = FALSE, recursive = TRUE)
            data.table::fwrite(coloc_qtls, file = split_path)
            return(split_path)
        } else {
            return(coloc_qtls)
        }
    })) # end timeit()

    if (split_by_group) {
        messager("+ Returning split file paths.")
    } else {
        coloc_QTLs <- data.table::rbindlist(coloc_QTLs, fill = TRUE)
        # Save all coloc results in one dataframe
        if (save_path != FALSE) {
            # save_path="./Data/GWAS/Nalls23andMe_2019/_genome_wide/coloc_topQTL.tsv"
            dir.create(dirname(save_path), showWarnings = FALSE, recursive = TRUE)
            data.table::fwrite(coloc_QTLs, file = save_path, sep = "\t")
        }
    }
    return(coloc_QTLs)
}
