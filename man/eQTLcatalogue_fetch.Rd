% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/eQTLcatalogue_fetch.R
\name{eQTLcatalogue_fetch}
\alias{eQTLcatalogue_fetch}
\title{Query eQTL Catalogue}
\usage{
eQTLcatalogue_fetch(
  unique_id,
  query_granges,
  method = c("REST", "tabix"),
  quant_method = "ge",
  multithread_tabix = FALSE,
  add_qtl_id = TRUE,
  convert_genes = TRUE,
  suffix = ".QTL",
  timeout = 5 * 60,
  conda_env = "echoR_mini",
  nThread = 1,
  verbose = TRUE
)
}
\arguments{
\item{unique_id}{Unique eQTL Catalogue ID assigned in metadata
("unique_id" column in \code{data(meta)}).}

\item{method}{Method for querying eQTL Catalogue:
\itemize{
\item{"REST" (default): }{Uses the REST API. Slow but can be used by anyone.}
\item{"tabix"}{Uses tabix \link[echotabix]{query}.
Fast, but requires the user to first get their IP address whitelisted 
by the EMBL-EBI server admin by putting in a request
\href{https://www.ebi.ac.uk/about/contact/support/}{here}.} 
}
\emph{Note}: "tabix" is about ~17x faster than the REST API,
 but is currently a far less reliable method than the REST API because 
 tabix tends to get blocked by eQTL Catalogue's firewall.
See \href{https://github.com/RajLabMSSM/catalogueR/issues/5}{here}
for more details.}

\item{quant_method}{eQTL Catalogue actually contains more than just
 eQTL data.
For each dataset, the following kinds of QTLs can be queried:
\describe{
\item{gene expression QTL}{\code{quant_method="ge"} (\emph{default})
or \code{quant_method="microarray"}, depending on the dataset.
\strong{catalogueR} will automatically select whichever option is available.}
\item{exon expression QTL}{\emph{*under construction*}
\code{quant_method="ex"}}
\item{transcript usage QTL}{\emph{*under construction*}
\code{quant_method="tx"}}
\item{promoter, splice junction and 3' end usage QTL}{
\emph{*under construction*}  \code{quant_method="txrev"}}
}}

\item{multithread_tabix}{Multi-thread across within a single tabix file query
(good when you have one-several large loci).}

\item{add_qtl_id}{Add "qtl_id" (i.e. "unique_id") column to the query result.}

\item{convert_genes}{Convert Ensembl IDs to HGNC symbols.}

\item{conda_env}{Conda environment to search for tabix executable in.}

\item{nThread}{The number of CPU cores you want to use to speed up your
queries through parallelization.}

\item{verbose}{Show more (\code{=TRUE}) or fewer (\code{=FALSE}) messages.}

\item{query_dat}{\link[data.table]{data.table} of GWAS summary statistics.}

\item{chrom}{Chromosome of the query window.}

\item{bp_lower}{Minimum basepair position of the query window.}

\item{bp_upper}{Maxmimum basepair position of the query window.}
}
\description{
Query eQTL Catalogue datasets with multiple methods options.
}
\examples{
data("meta")
query_granges <- echodata::BST1
GWAS.QTL_manual <- catalogueR::eQTLcatalogue_fetch(
  query_granges = query_granges,
  unique_id = meta$unique_id[1])
}
\seealso{
Other eQTL Catalogue: 
\code{\link{eQTLcatalogue_header}},
\code{\link{eQTLcatalogue_iterate_fetch}()},
\code{\link{eQTLcatalogue_query}()},
\code{\link{eQTLcatalogue_search_metadata}()},
\code{\link{fetch_restAPI}()},
\code{\link{fetch_tabix}()},
\code{\link{merge_gwas_qtl}()},
\code{\link{meta}}
}
\concept{eQTL Catalogue}
